/** @file output_control.cpp
 *  @brief Implementation file for the prototypes declared in the output_control.h interface module.
 *      
 *  @author Adam Porsch & Houston Fortney
 *  @bug No known bugs.
 */

#include "HAL.h"
#include "output_control.h"
#include <stdlib.h>
#include <math.h>

#pragma region "defintions, prototypes and variables restricted to the scope of this module"

#define AD5791_DAC_INIT_COMMAND 0x200302
#define AD5791_DAC_WRITE_COMMAND 0x100000
#define COMPUTE_AD5791_CODE(voltage, full_scale_divisor) (AD5791_DAC_WRITE_COMMAND | (0xFFFFF & (int)(0x7FFFFu*((voltage)/(full_scale_divisor)))))

struct output_data
{
	volatile union four_byte_pack DAC_code;
	union four_byte_pack next_DAC_code;
	unsigned int phase_accumulator;
	volatile unsigned int phase_increment;
	uint32_t int_DAC_code_table[2][SINE_TABLE_SIZE];
	volatile uint32_t active_DAC_table_index;
};

struct output_data output;

output_stage_selection_type presently_selected_output_stage = OUTSTG_SEL_BOTH;

void execute_one_shot_DAC_write_sequence(void);

#pragma endregion "defintions and variables restricted to the scope of this module"

#pragma region "general output control functions"

void initialize_output_control_parameters(void)
{
	output.active_DAC_table_index = 0;
	output.phase_accumulator = 0;
	output.phase_increment = 0;
}
#pragma endregion "general output control functions"

#pragma region "AD5791 DAC Manipulation Functions"

/**
 * @brief Output Waveform ISR
 * 
 * This Timer ISR is the heart of the waveform generation capabilities. It's executed at a rate as
 * defined by OUTPUT_SAMPLING_FREQUENCY. It is dependent on the int_DAC_code_table being populated
 * with integer DAC code values, already scaled and formatted properly with calibration values included.
 * 
 * THIS ISR IS EXTREMELY TIMING CRITICAL. INCLUDING BOTH CONTEXT SWITCHES, IT TAKES APPROXIMATELY
 * 670nS TO EXECUTE. AT A 600kHz SAMPLING RATE, IT EXECUTES EVERY 1.66uS, RESULTING IN A CPU UTILIZAITON
 * OF APPROX. 40%. ANY MODIFICATIONS TO THIS ROUTINE MUST BE ACCOMPANIED WITH VERIFICATION TO ENSURE
 * THE ISR WILL EXECUTE IN ENOUGH TIME AND STILL MEET OVERALL TIMING REQUIREMENTS.
 * 
 * @param none
 * 
 * @return void
 */

__attribute__ ((section(".ramfunc")))
void OUTPUT_UPDATE_TIMER_ISR()
{
	//Move data down pipeline (reverse the endianness here)
	output.DAC_code.bytes[0] = output.next_DAC_code.bytes[2];
	output.DAC_code.bytes[1] = output.next_DAC_code.bytes[1];
	output.DAC_code.bytes[2] = output.next_DAC_code.bytes[0];
	
	// Initiate PDC transfer
	SET_SPI_PDC_TX_POINTER(&output.DAC_code.bytes[0]);
	SET_SPI_PDC_TX_COUNT(3);
	
	//Clear ISR flag
	CLEAR_OUTPUT_UPDATE_TIMER_FLAG();
	
	// Compute new value
	output.next_DAC_code.packed = output.int_DAC_code_table[output.active_DAC_table_index][TABLE_INDEX(output.phase_accumulator)];
	
	// Update phase accumulator
	output.phase_accumulator += output.phase_increment;
}

void init_AD5791_DAC(void)
{
	output.next_DAC_code.packed = AD5791_DAC_INIT_COMMAND;
	execute_one_shot_DAC_write_sequence();
}

void generate_DAC_code_table(float amplitude, float offset, float full_scale_divisor)
{
	uint32_t i;
	uint32_t pending_active_DAC_table_index;
	
	if(output.active_DAC_table_index == 1)
	{
		pending_active_DAC_table_index = 0;
	}
	else
	{
		pending_active_DAC_table_index = 1;
	}
	
	for(i = 0; i < SINE_TABLE_SIZE; i++)
	{
		output.int_DAC_code_table[pending_active_DAC_table_index][i] = COMPUTE_AD5791_CODE((amplitude * sine_table[i]  + offset), full_scale_divisor);       //TODO: add in cal factors from calibration.h
	}
	
	output.active_DAC_table_index = pending_active_DAC_table_index;                 //Throw the switch!
}

void bring_DAC_output_to_zero(output_shape_type output_shape)
{
	if(output_shape == SHAPE_DC)
	{
		update_DAC_output_while_in_DC_mode(0,1);        //full scale divisor is a don't care when going to zero.
	}
	else if(output_shape == SHAPE_SINE)
	{
		generate_DAC_code_table(0,0,1);
	}

}

void update_DAC_output_while_in_DC_mode(float desired_output_amplitude, float full_scale_divisor)
{
	generate_DAC_code_table(0, desired_output_amplitude, full_scale_divisor);						//under the hood, in DC mode, desired user amplitude setting is generated by passing it in as "offset" parameter.
	output.next_DAC_code.packed = output.int_DAC_code_table[output.active_DAC_table_index][0];      //just grab the 1st value for DC mode since they're all the same
	execute_one_shot_DAC_write_sequence();
}

/**
 * \brief called when only one value needs to be written to AD5791 DAC
 * 
 * See comments in implementation for further details of how this works.
 * 
 * \param 
 * 
 * \return void
 */
void execute_one_shot_DAC_write_sequence(void)
{
	OUTPUT_UPDATE_TIMER_ISR();									//"call" ISR in order to take new DC value and kick of SPI Tx so it gets shifted into DAC.
	while(!IS_SPI_PDC_TXBUFFER_EMPTY());						//wait for PDC to push data out before we kick off timer, which in turn will then fire off LDAC toggle
	ENABLE_TIMER_CLOCK();										//Enables timer clock but doesn't actually start counting up yet.
	ENABLE_TIMER_CLOCK_DISABLE_ON_RC_COMPARE();					//This ensures the LDAC line will only load once. Once RC is hit, the timer peripheral will disable its own clock
	ISSUE_TIMER_SW_TRIGGER();									//This causes the timer counter to reset and start the count up to the LDAC toggle (low when RA is hit, back high when RC is hit)
}

#pragma endregion "AD5791 DAC Manipulation Functions"

#pragma region "Output Stage Hardware Manipulation Functions"

void configure_DAC_input_to_desired_output_stage(output_mode_type output_mode, output_stage_selection_type desired_output_stage)
{
	uint32_t IO_line_state;
	uint32_t IO_line_mask = (LV_DAC_IN_MASK | HV_DAC_IN_MASK | LV_OUTMODE_SEL_MASK | HV_OUTMODE_SEL_MASK);     //we're always manipulating the respective DAC input and OUTMODEL SEL masks in this function
	
	if(desired_output_stage == OUTSTG_SEL_LOW_VOLTAGE)
	{
		IO_line_state = LV_DAC_IN_ENABLE | HV_DAC_IN_DISABLE | HV_OUTMODE_SEL_VOLTAGE;      //despite being disabled and a don't care, force HV outmode to known "voltage" state. Helps with system testing.
		
		if(output_mode == VOLTAGE_MODE)
		{
			IO_line_state |= LV_OUTMODE_SEL_VOLTAGE;
		}
		else if(output_mode == CURRENT_MODE)
		{
			IO_line_state |= LV_OUTMODE_SEL_CURRENT;
		}
		
		presently_selected_output_stage = OUTSTG_SEL_LOW_VOLTAGE;
	}
	else if(desired_output_stage == OUTSTG_SEL_HIGH_VOLTAGE)
	{
		IO_line_state = LV_DAC_IN_DISABLE | HV_DAC_IN_ENABLE | LV_OUTMODE_SEL_VOLTAGE;      //despite being disabled and a don't care, force LV outmode to known "voltage" state. Helps with system testing.
		
		if(output_mode == VOLTAGE_MODE)
		{
			IO_line_state |= HV_OUTMODE_SEL_VOLTAGE;
		}
		else if(output_mode == CURRENT_MODE)
		{
			IO_line_state |= HV_OUTMODE_SEL_CURRENT;
		}
		
		presently_selected_output_stage = OUTSTG_SEL_HIGH_VOLTAGE;
	}
	else                                                                                    //else, safely default to disabling inputs to both output stages
	{
		IO_line_state = (LV_DAC_IN_DISABLE | HV_DAC_IN_DISABLE | LV_OUTMODE_SEL_VOLTAGE | HV_OUTMODE_SEL_VOLTAGE);
		
		presently_selected_output_stage = OUTSTG_SEL_BOTH;
	}
	
	set_HW_configuration_lines(IO_PORT, IO_line_mask, IO_line_state);
}

output_stage_selection_type get_presently_selected_output_stage(void)
{
	return(presently_selected_output_stage);
}

void set_low_voltage_voltage_range_HW(voltage_range_type range)
{
	uint32_t LV_range_IO_line_state = 0;
	
	switch(range)
	{
		case VRANGE_100mV:
			LV_range_IO_line_state = LV_VRNG_100MV;
			break;
		
		case VRANGE_1V:
			LV_range_IO_line_state = LV_VRNG_1V;
			break;
		
		case VRANGE_10V:
			LV_range_IO_line_state = LV_VRNG_10V;
			break;
		
		case VRANGE_10mV:
		default:
			LV_range_IO_line_state = LV_VRNG_10MV;
			break;
	}
	
	set_HW_configuration_lines(LV_IO_PORT, LV_VRNG_MASK, LV_range_IO_line_state);
}

void set_low_voltage_current_range_HW(current_range_type range)
{
    uint32_t LV_range_IO_line_state = 0;
    
    switch(range)
    {
        case IRANGE_10uA:
            LV_range_IO_line_state = LV_IRNG_10UA;
            break;
        
        case IRANGE_100uA:
            LV_range_IO_line_state = LV_IRNG_100UA;
            break;
        
        case IRANGE_1mA:
            LV_range_IO_line_state = LV_IRNG_1MA;
            break;
        
        case IRANGE_10mA:
            LV_range_IO_line_state = LV_IRNG_10MA;
            break;
        
        case IRANGE_100mA:
            LV_range_IO_line_state = LV_IRNG_100MA_AC_BYPASS;
            break;
        
        case IRANGE_1uA:
        default:
            LV_range_IO_line_state = LV_IRNG_1UA;
            break;
    }
    
    set_HW_configuration_lines(LV_IO_PORT, LV_IRNG_MASK, LV_range_IO_line_state);
}

void set_high_voltage_current_range_HW(current_range_type range)
{
    uint32_t HV_range_IO_line_state = 0;
    
    switch(range)
    {
        case IRANGE_HV_AC_BYPASS:
            HV_range_IO_line_state = HV_IRNG_AC_BYPASS;
            break;
            
        case IRANGE_10uA:
            HV_range_IO_line_state = HV_IRNG_10UA;
            break;
        
        case IRANGE_100uA:
            HV_range_IO_line_state = HV_IRNG_100UA;
            break;
        
        case IRANGE_1mA:
            HV_range_IO_line_state = HV_IRNG_1MA;
            break;
        
        case IRANGE_10mA:
            HV_range_IO_line_state = HV_IRNG_10MA;
            break;
        
        case IRANGE_1uA:
        default:
            HV_range_IO_line_state = HV_IRNG_1UA;
            break;
    }
    
    set_HW_configuration_lines(HV_IO_PORT, HV_IRNG_MASK, HV_range_IO_line_state);
    
}

void shunt_output_stage(output_stage_selection_type output_stage)
{
	uint32_t IO_line_state = (LV_OUTPUT_SHUNT_ENABLE | HV_OUTPUT_SHUNT_ENABLE);     //default to shunt both unless otherwise told
	uint32_t IO_line_mask = (LV_OUTPUT_SHUNT_MASK | HV_OUTPUT_SHUNT_MASK);
	
	if(output_stage == OUTSTG_SEL_LOW_VOLTAGE)
	{
		IO_line_state = LV_OUTPUT_SHUNT_ENABLE;
		IO_line_mask = LV_OUTPUT_SHUNT_MASK;
	}
	else if(output_stage == OUTSTG_SEL_HIGH_VOLTAGE)
	{
		IO_line_state = HV_OUTPUT_SHUNT_ENABLE;
		IO_line_mask = HV_OUTPUT_SHUNT_MASK;
	}
	
	set_HW_configuration_lines(IO_PORT, IO_line_mask, IO_line_state);
}

void unshunt_output_stage(output_stage_selection_type output_stage)
{
	uint32_t IO_line_state = 0;
	uint32_t IO_line_mask = 0;
	
	if(output_stage != OUTSTG_SEL_BOTH)
	{
		if(output_stage == OUTSTG_SEL_LOW_VOLTAGE)
		{
			IO_line_state = LV_OUTPUT_SHUNT_DISABLE;
			IO_line_mask = LV_OUTPUT_SHUNT_MASK;
		}
		else if(output_stage == OUTSTG_SEL_HIGH_VOLTAGE)
		{
			IO_line_state = HV_OUTPUT_SHUNT_DISABLE;
			IO_line_mask = HV_OUTPUT_SHUNT_MASK;
		}
		
		set_HW_configuration_lines(IO_PORT, IO_line_mask, IO_line_state);
	}
}

void connect_output_stage_to_output_terminals(output_stage_selection_type output_stage)
{
	uint32_t IO_line_state = 0xFFFFFFFF;                            //init to safe state for IO lines in case of "output_stage" being corrupt
	
	if(output_stage != OUTSTG_SEL_BOTH)
	{
		if(output_stage == OUTSTG_SEL_LOW_VOLTAGE)
		{
			IO_line_state = OUTSTG_SEL_LV;
		}
		else if(output_stage == OUTSTG_SEL_HIGH_VOLTAGE)
		{
			IO_line_state = OUTSTG_SEL_HV;
		}
		
		set_HW_configuration_lines(OUT_TERMINAL_SEL_IO_PORT, OUTSTG_SEL_MASK, IO_line_state);
	}
	
}

void disable_output_terminals(void)
{
	set_HW_configuration_lines(OUT_TERMINAL_SEL_IO_PORT, OUTSTG_SEL_MASK, OUTSTG_SEL_OPEN);
}

void select_front_or_rear_output_terminals(terminal_selection_type terminal_selection)
{
	uint32_t IO_line_state = 0XFFFFFFFF;                            //init to safe state for IO lines in case of "terminal_selection" being corrupt
	
	if(terminal_selection == TERMINALS_FRONT)
	{
		IO_line_state = FRONT_REAR_TERM_FRONT_SEL;
	}
	else if(terminal_selection == TERMINALS_REAR)
	{
		IO_line_state = FRONT_REAR_TERM_REAR_SEL;
	}
	
	set_HW_configuration_lines(OUT_TERMINAL_SEL_IO_PORT, FRONT_REAR_TERM_MASK, IO_line_state);
	
}

#pragma endregion "Output Stage Hardware Manipulation Functions"

#pragma region "Output Waveform Functions"

void set_output_frequency(float desired_output_frequency)
{
    output.phase_increment = get_phase_increment(desired_output_frequency, OUTPUT_SAMPLING_FREQUENCY);
}

void set_output_shape(output_shape_type desired_output_shape, float amplitude, float offset, float full_scale_divisor)
{
    if(presently_selected_output_stage == OUTSTG_SEL_LOW_VOLTAGE)
    {
        amplitude = -amplitude;
        offset = -offset;        
    }
    
    if(desired_output_shape == SHAPE_DC)
    {
        //HAS_RC_COMPARED_SINCE_LAST_STAUS_REG_READ();
        //while(!HAS_RC_COMPARED_SINCE_LAST_STAUS_REG_READ());   //this assumes the timer is actively firing, probably won't work on power up and transition to enabled output
        DISABLE_TIMER_CLOCK();
        DISABLE_TIMER_INTERRUPT();        
        update_DAC_output_while_in_DC_mode(amplitude, full_scale_divisor);        
    }
    else if(desired_output_shape == SHAPE_SINE)
    {
        generate_DAC_code_table(amplitude, offset, full_scale_divisor);
        DISABLE_TIMER_CLOCK_DISABLE_ON_RC_COMPARE();
        ENABLE_TIMER_INTERRUPT();
        ENABLE_TIMER_CLOCK();
        ISSUE_TIMER_SW_TRIGGER();       
    }    
}    

#pragma endregion "Output Waveform Functions"